#! /usr/bin/env python3
from __future__ import annotations

import argparse
import collections.abc
import contextlib
import dataclasses
import datetime
import functools
import getpass
import logging
import pathlib
import platform
import pwd
import re
import string
import subprocess
import sys
from typing import TYPE_CHECKING, Any, Generator, Literal, cast

if sys.version_info > (3, 11):
    from typing import NoReturn, Self
elif TYPE_CHECKING:
    from typing_extensions import NoReturn, Self

_logger = logging.getLogger("install")

THIS_DIR = pathlib.Path(__file__).parent

parser = argparse.ArgumentParser(
    prog="dotfiles-installer", description="Helper script to install the dotfiles in this repository"
)
parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
parser.add_argument("--email", help="E-Mail address to use for configuration")
parser.add_argument(
    "--confirm-all-stages",
    "-y",
    default=False,
    action="store_true",
    help="Confirm execution of all stages",
)
skip_stages_group = parser.add_argument_group(
    "Skip stages", description="Arguments to skip individual stages of the installation"
)


def configure_logging(verbose: bool) -> None:
    _logger.setLevel(logging.DEBUG if verbose else logging.INFO)

    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.addFilter(lambda record: record.levelno < logging.WARNING)
    stdout_handler.setFormatter(logging.Formatter("%(message)s"))

    stderr_handler = logging.StreamHandler()
    stderr_handler.setLevel(logging.WARNING)
    stderr_handler.setFormatter(logging.Formatter("%(levelname)s: %(message)s"))

    _logger.addHandler(stdout_handler)
    _logger.addHandler(stderr_handler)


@contextlib.contextmanager
def indent_logger(indent: str = "  ") -> Generator[None, Any, None]:
    for handler in _logger.handlers:
        if handler.formatter and handler.formatter._fmt:
            handler.setFormatter(logging.Formatter(indent + handler.formatter._fmt))
    try:
        yield
    finally:
        for handler in _logger.handlers:
            if handler.formatter and handler.formatter._fmt:
                handler.setFormatter(logging.Formatter(handler.formatter._fmt[len(indent) :]))


def input_with_default(_prompt: str, default: str | None) -> str:
    """Prompt for a user input and return a default value on empty input

    :param _prompt: Prompt to write to stdout
    :param default: Default value
    :return: User input or default value
    """
    resp = input(_prompt + " ")
    if default and not resp:
        resp = default
    return resp


def confirm(prompt_: str, default: Literal["y", "n"] | None = None) -> bool:
    if default == "y":
        options = "(Y/n)"
    elif default == "n":
        options = "(y/N)"
    elif default is None:
        options = "(y/n)"

    resp = input_with_default(f"{prompt_} {options}", default)
    if resp.upper() == "Y":
        return True
    elif resp.upper() == "N":
        return False
    else:
        if resp.upper():
            print(f"Invalid input: '{resp}'")
        return confirm(prompt_, default)


def prompt(
    prompt_: str,
    default: str | None = None,
    confirm_required: bool = True,
    validator: collections.abc.Callable[[str], bool] | None = None,
) -> str:
    input_prompt = f"{prompt_} ({default})" if default is not None else prompt_

    resp = input_with_default(input_prompt, default)
    if resp == default:
        # No need to validate and confirm if we use the default
        return resp

    if validator is not None and not validator(resp):
        print(f"Invalid input: {resp}")
        return prompt(prompt_, default, confirm_required, validator)

    if confirm_required and not confirm(f"Confirm '{resp}'?", default="y"):
        return prompt(prompt_, default=default, confirm_required=confirm_required, validator=validator)
    return resp


def stage(
    name: str,
    interactive_confirm: bool = False,
    predicate: collections.abc.Callable[[], bool] | None = None,
    abort_on_error: bool = False,
) -> collections.abc.Callable[..., collections.abc.Callable[[Config], None]]:
    """Make a function to wrap a function as a stage of the installation

    :param name: Name of the stage
    :param interactive_confirm: Whether execution of this stage requires an interactive confirm, defaults to False
    :param predicate: Function returning at runtime whether this stage should run, defaults to None
    :param abort_on_error: Whether to abort installation on error, defaults to False
    :return: Decorator function
    """

    def dec(func: collections.abc.Callable[[Config], None]) -> collections.abc.Callable[[Config], Any]:
        flag_name = name.lower().replace(" ", "-").replace(".", "")
        skip_stages_group.add_argument(
            f"--no-{flag_name}",
            action="append_const",
            dest="skipped_stages",
            const=flag_name,
            help=f"Skip the stage '{name}'",
        )

        def wrapper(cfg: Config) -> None:
            if flag_name in cfg.skipped_stages:
                return

            if predicate is not None and not predicate():
                _logger.info(f"{name} is not required, skip")
                return
            if not cfg.confirm_all_stages and interactive_confirm and not confirm(f"{name}?", default="y"):
                return

            _logger.info(f"{name} ...")
            try:
                with indent_logger():
                    func(cfg)
            except Exception as exc:
                error_msg = f"Error during '{name}': {exc}"
                if abort_on_error:
                    parser.exit(status=1, message=error_msg)
                else:
                    _logger.error(error_msg)
            else:
                _logger.info(f"{name} - done")

        return wrapper

    return dec


Platforms = Literal["Linux", "Darwin", "Java", "Windows"]


@dataclasses.dataclass
class Config:
    username: str
    full_name: str
    email: str
    confirm_all_stages: bool
    platform: Platforms = dataclasses.field(
        default_factory=cast(collections.abc.Callable[[], Platforms], platform.system)
    )
    skipped_stages: list[str] = dataclasses.field(default_factory=list)
    timestamp: datetime.datetime = dataclasses.field(default_factory=datetime.datetime.now)

    @classmethod
    def from_env(cls, email: str, skipped_stages: list[str], confirm_all_stages: bool, **kwargs: Any) -> Self:
        username = getpass.getuser()
        return cls(
            username=username,
            full_name=pwd.getpwnam(username).pw_name,
            email=email,
            confirm_all_stages=confirm_all_stages,
            skipped_stages=skipped_stages,
        )


class DotfileManager:
    def __init__(self, timestamp: datetime.datetime) -> None:
        self._timestamp = timestamp
        self._backup_suffix = f".pre-dotfiles-installer-{self._timestamp.strftime('%Y-%m-%d_%H-%M-%S')}"

    def _cleanup_destination_path(self, path: pathlib.Path) -> None:
        self._backup_file(path)
        self._cleanup_symlink(path)

    def _backup_file(self, path: pathlib.Path) -> pathlib.Path | None:
        """Backup an existing file in `path`

        :param path: Path to back-up
        :return: Back-up path if backed-up, else None
        """
        if path.is_file():
            backup_path = path.parent / f"{path.name}{self._backup_suffix}"
            _logger.info(f"Rename existing {path.name} file to {backup_path}")
            path.rename(backup_path)
            return backup_path
        return None

    def _cleanup_symlink(self, path: pathlib.Path) -> None:
        """Remove a symlink in `path` if it exists

        :param path: Path to remove the symlink from
        """
        if path.is_symlink():
            _logger.info("Remove symlink of %s to %s", path, path.resolve())
            path.unlink()

    def _file_content_matches(self, text: str, path: pathlib.Path) -> bool:
        """Check if the content of a file matches a string

        :param text: Text to check the file content against
        :param path: Path to check
        :return: Whether the content of `path` matches `text`
        """
        if path.is_file() and path.read_text() == text:
            return True
        return False

    def safe_symlink(self, source: pathlib.Path, destination: pathlib.Path) -> None:
        """Create a symlink. If `destination` is an existing file, back it up.
        If `destination` is a symlink, remove it first.

        :param source: Source file
        :param destination: Path to create the symlink in
        """
        if destination.is_dir():
            destination = destination / source.name

        self._cleanup_destination_path(destination)
        _logger.info("Create symlink from %s to %s", destination, source)
        destination.symlink_to(source)

    def safe_write(self, text: str, destination: pathlib.Path) -> None:
        """Write `text` to a file if it differs. If the file exists already back it up first

        :param text: Text to write to `destination`
        :param destination: Path of the file to write to
        """
        if self._file_content_matches(text, destination):
            _logger.info("%s is up-to-date", destination)
            return
        else:
            _logger.info("%s differs from desired content", destination)

        self._cleanup_destination_path(destination)
        _logger.info("Write %s", destination)
        destination.write_text(text)


def no_symlink_exists(symlink: pathlib.Path, path: pathlib.Path) -> bool:
    return symlink.resolve() != path.resolve()


def not_(func: collections.abc.Callable[[], bool]) -> bool:
    return not func()


@stage("Create .gitconfig")
def create_gitconfig(cfg: Config) -> None:
    gitconfig_content = string.Template((THIS_DIR / ".gitconfig.template").read_text()).safe_substitute(
        full_name=cfg.full_name, email=cfg.email
    )
    DotfileManager(cfg.timestamp).safe_write(gitconfig_content, pathlib.Path.home() / ".gitconfig")


@stage(
    "Link .gitignore",
    predicate=functools.partial(no_symlink_exists, pathlib.Path.home() / ".gitignore", THIS_DIR / ".gitignore"),
)
def link_gitignore(cfg: Config) -> None:
    DotfileManager(cfg.timestamp).safe_symlink(THIS_DIR / ".gitignore", pathlib.Path.home())


@stage(
    "Link .tmux.conf",
    predicate=functools.partial(no_symlink_exists, pathlib.Path.home() / ".tmux.conf", THIS_DIR / ".tmux.conf"),
)
def link_tmux_conf(cfg: Config) -> None:
    DotfileManager(cfg.timestamp).safe_symlink(THIS_DIR / ".tmux.conf", pathlib.Path.home())


@stage(
    "Link .pythonstartup",
    predicate=functools.partial(no_symlink_exists, pathlib.Path.home() / ".pythonstartup", THIS_DIR / ".pythonstartup"),
)
def link_pythonstartup(cfg: Config) -> None:
    DotfileManager(cfg.timestamp).safe_symlink(THIS_DIR / ".pythonstartup", pathlib.Path.home())


@stage(
    "Install oh-my-zsh",
    interactive_confirm=True,
    predicate=functools.partial(not_, (pathlib.Path.home() / ".oh-my-zsh").exists),
    abort_on_error=False,
)
def install_omz(cfg: Config) -> None:
    subprocess.run(
        '/usr/bin/sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"',
        stdin=subprocess.DEVNULL,
        check=True,
        shell=True,  # noqa: S602
    )


@stage(
    "Install pyenv",
    interactive_confirm=True,
    predicate=functools.partial(not_, (pathlib.Path.home() / ".pyenv").exists),
)
def install_pyenv(cfg: Config) -> None:
    subprocess.run("curl https://pyenv.run | bash", shell=True, check=True)  # noqa: S602, S607


@stage(
    "Install fzf", interactive_confirm=True, predicate=functools.partial(not_, (pathlib.Path.home() / ".fzf").exists)
)
def install_fzf(cfg: Config) -> None:
    fzf_dir = pathlib.Path.home() / ".fzf"
    subprocess.run(
        [  # noqa: S603
            "/usr/bin/git",
            "clone",
            "--depth",
            "1",
            "https://github.com/junegunn/fzf.git",
            str(fzf_dir),
        ],
        check=True,
    )
    subprocess.run([str(fzf_dir / "install")], check=True)  # noqa: S603


def validate_vscode_extension_names(extensions: collections.abc.Iterable[str]) -> None:
    """Validate that VSCode extension names contain two elements, publisher and extension, separated by a dot.
    Each element must only contain characters, numbers, dashes and underscores.
    """
    for extension in extensions:
        if not re.match(r"^[\w\d_-]+\.[\w\d_-]+$", extension):
            raise ValueError(f"Invalid extension name: {extension}")


@stage("Install VSCode extensions", interactive_confirm=True, abort_on_error=False)
def install_vscode_extensions(cfg: Config) -> None:
    proc = subprocess.run(
        ["code", "--list-extensions"], stdout=subprocess.PIPE, encoding="UTF-8", check=True  # noqa: S603, S607
    )
    available_extensions = set(proc.stdout.splitlines())
    validate_vscode_extension_names(available_extensions)

    required_extensions = set((THIS_DIR / "vscode-extensions.txt").read_text().splitlines())
    validate_vscode_extension_names(required_extensions)
    extensions_to_install = required_extensions - available_extensions

    if not extensions_to_install:
        _logger.info("No extensions to install")
        return

    args: list[str] = []
    for extension in extensions_to_install:
        args.append("--install-extension")
        args.append(extension)
    try:
        subprocess.run(["code", *args], check=True)  # noqa: S603, S607
    except:
        _logger.error("Error installing VSCode extensions")
        raise


@stage(
    "Create .zshrc",
    predicate=functools.partial(no_symlink_exists, pathlib.Path.home() / ".zshrc", THIS_DIR / ".zshrc"),
)
def link_zshrc(cfg: Config) -> None:
    DotfileManager(cfg.timestamp).safe_symlink(THIS_DIR / ".zshrc", pathlib.Path.home())


def main() -> NoReturn:
    namespace = parser.parse_args()
    if not namespace.email:
        namespace.email = prompt("Default E-Mail address?")
    configure_logging(namespace.verbose)

    try:
        cfg = Config.from_env(**vars(namespace))
    except Exception as exc:
        parser.exit(status=1, message=f"Error creating configuration: {exc}")

    try:
        create_gitconfig(cfg)
        link_gitignore(cfg)
        link_tmux_conf(cfg)
        link_pythonstartup(cfg)
        install_omz(cfg)
        install_fzf(cfg)
        install_pyenv(cfg)
        install_vscode_extensions(cfg)
        link_zshrc(cfg)
    except KeyboardInterrupt:
        parser.exit(status=2, message="\nAborted!\n")

    sys.exit(0)


if __name__ == "__main__":
    main()
